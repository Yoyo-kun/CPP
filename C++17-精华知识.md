-   **C++ 工作流程：**

    -   ```c++
        .h/.cpp  -->  [预处理]  -->  .i  -->  [编译]  -->  .asm  -->  [汇编]  -->  .obj  -->  [链接]  -->  .exe/.dll
        ```

-   **头文件：**

    -   ```c++
        #include "fileName.h"
        #include <fileName>
        // 这两者有什么区别？
        // 使用双引号 "" 时，编译器首先在当前工作目录下寻找文件 fileName.h。这种方式一般用于包含自己项目中创建的文件。
        // 使用尖括号 <> 时，编译器会在指定的“标准库”或“包含目录”中查找文件 fileName。这种方式一般用于引入系统或标准库提供的文件。
        ```

-   **`main() `函数：**

    -   ```c++
        int main(int argc, char* argv[])
        // argc 表示传递给程序的参数的个数
        // argv[0] 是程序的名称或路径，但不可依赖此获取程序名称
        // argv[1]、argv[2]、argv[3]...为传递给程序的参数
        // 一般在 terminal 下才能更好发挥作用，如有 GUI 则无需设定任何值
        ```

-   **输入输出流：**

    -   以下相较于 C 均具有类型安全：
    -   `std::cout`
    -   `std::cin`，不会进行类型检查，因此，不会自动处理错误输入；
    -   `std::cerr`，标准错误流，专门用于输出错误消息。
    -   `std::endl`

-   **常见转义字符：**

    - `\n`：换行符，移动到下一行的起始位置。
    - `\r`：回车符，移动到当前行的起始位置。
    - `\t`：制表符，插入水平制表符，用于排版。
    - `\\`：反斜杠字符。
    - `\"`：双引号，用于在字符串中表示引号。

-   **名称空间：**

    -   在 `.h` 文件中声明名称空间，在对应 `.cpp` 文件中用以下方法实现：

        -   ```c++
            returntype namespaceName::function()
            {
                // ...
            }
            
            // :: 为 作用域解析运算符
            ```

        -   ```c++
            namespace namespaceName
            {
                returntype funcion()
                {
                    // ...
                }
            }
            ```

    -   名称空间过长问题解决方案：

        -   ```c++
            // 使用同名来化简
            namespace myNamespace = namespace_top::namespace_middle::namespace_bottom;
            myNamespaces::foo();
            ```

-   **`using` 指令：**

    -   虽然此方法便捷，但不应过度使用！

    -   如果使用了所有的名称空间，在某种意义上就是完全取消了名称空间；

    -   如果使用了两个具有同名函数的名称空间，将再次出现名称冲突问题；

        -   ```c++
            namespace A {
                void foo() {
                    std::cout << "A::foo()" << std::endl;
                }
            }
            
            namespace B {
                void foo() {
                    std::cout << "B::foo()" << std::endl;
                }
            }
            
            using namespace A;  // 引入命名空间 A
            using namespace B;  // 同时引入命名空间 B（会引起冲突）
            
            int main() {
                // 这将导致命名冲突
                foo();  // 编译错误：foo 在 A 和 B 中都有定义
                return 0;
            }
            ```

    -   应当知晓每段代码在哪个名称空间中运行，这样就不会无意中调用错误版本的函数；

    -   **切勿在 头文件 中使用任何 `using` 指令或声明；**

        -   ```c++
            // 使用 using 指令
            using namespace std;
            ```

            -   会改变引入此头文件的源文件的全局命名空间。即，若在 `std` 空间下的函数如果在此 `.h` 文件中被修改，则次修改会作用到全局，而引发命名冲突；此外，可能在某个源文件中调用了意图中的函数，但实际上调用了不同命名空间中的同名函数，这会导致编译错误或运行时错误；

            -   解决方案是在此 `.h` 文件对应的 `.cpp` 文件内使用 `using`【见上一条中，名称空间的实现方法】；

            -   此外，还可以通过名称空间的封装方式，限定 `using`：

                -   ```c++
                    namespace namespaceName
                    {
                    	using std::cout;
                    	// 在特定的命名空间中使用using
                    
                    	returntype function();
                    }
                    ```

        -   ```c++
            // 使用 using 声明
            using std::cout;
            ```

            -   同上，略；

    -   由此，我们可以看出，命名空间实际上是对代码的一种封装。这种封装在部分特性类似于类的封装；

-   **字面量：**

    -   需注意的不多，只需记住：
        -   `123`，十进制；
        -   `0123`，八进制；
        -   `0x123`或`0X123`，十六进制；
        -   `0b110`或`0B110`，二进制；
        -   整数默认 `int`；
        -   浮点数默认 `double`；

-   **变量：**

    -   尽量给任何变量都进行初始化，以防止半随机值风险【debug 模式，通过 VS 中查 memory 和 watch 会发现未初始化的量都是 cc（一种优化，方便找出未初始化的量）】；

    -   **整型 和 size_t：**

        -   `(signed) int`、`(unsigned) int`，4 字节
        -   `(signed) short`、`(unsigned) short`，2字节
        -   对于下面的 `long`、`long long`型，最好在对应字面量的后面加上 `L`、`LL`
        -   `(signed) long`、`(unsigned) long`，4 字节
        -   `(signed) long long`、`(unsigned) long long`，8 字节
        -   `size_t`
            -   `#include <cstddef>`，必须引入此头文件；
            -   使用 `size_t`可以实现：
                -   无符号整数类型，防止负索引；
                -   防止溢出【可容纳系统最大可能的对象】；
                -   保持跨平台一致【部分平台的 `int` 大小可能不同】；
                -   使用广泛，易于集成【C++ 标准库和 STL 广泛使用 `size_t`】

    -   **浮点型：**

        -   `double`，8 字节；
        -   对于以下的 `float`、`long double`，最好在对应字面量的后面加上 `d`、`L`;
        -   `float`，4 字节；
        -   `long double`，8、12、16 字节，取决于编译器和平台【VS 上确实是 8 字节】；

    -   **字符型：**

        -   `char`，1 字节；

        -   `char16_t`，16 位字节；

            -   ```C++
                char16_t c16 = u'm';	// u 可省略
                ```

        -   `char32_t`，32 位字节；

            -   ```c++
                char32_t c32 = U'm';	// U 可省略
                ```

        -   `char64_t`，64 位字节；

            -   ```c++
                wchar_t w = L'm';
                ```

        -   后面三种类型主要用于处理 Unicode 字符，当前用处不大；

    -   **Boolean 类型：**

        -   `bool`，1 字节；

    -   **单字节：**

        -   `#include <cstddef>`，此头文件必须引入；

        -   `std::byte`

            -   在 C++17 之前，一般使用字符或无符号字符用于表示一个字节，但那些类型使得像在处理字符，理解起来会增加难度。

            -   `std::byte` 却能指明意图，即内存中的单个字节；

            -   `std::byte` 的初始化需要使用单元素列表进行直接列表初始化：

                -   ```c++
                    std::byte b{42};
                    // 相当于是：00101010
                    ```

            -   一些其他用法：

                -   ```c++
                    std::byte buffer[1024];
                    // 处理网络数据，读写字节流等
                    
                    std::byte flags = std::byte{ 0x0F };
                    // 00001111 in binary
                    
                    std::byte b{ 42 };
                    std::byte mask{ 0xF0 };
                    std::byte result = b & mask;
                    // 相当于 按位与 
                    ```

    -   **基本类型转换：**

        -   `(type)value`
            -   来自于 C，广泛使用，但不推荐；
        -   `type(value)`
            -   看似很自然，但很少使用；
        -   `static_cast<type>(value)`
            -   推荐使用，最复杂，最整洁，静态类型转换；

    -   **自动类型转换：**

        -   浮点型赋值给整数型，会进行窄化、丢失小数部分信息【给警告，但不报错】；
        -   整数型赋值给浮点型，无事发生；

    -   **获取类型及大小：**

        -   `typeid(value).name()`，获取 `value` 的 `type_info` 的信息；
        -   `std::type_index(typeid(value)).name()`
            -   `#include <typeindex>`，此头文件必须引入；
            -   与 `type_info` 类似，但提供比其更好的比较和哈希功能；
        -   `std::size()`，获取元素个数；
            -   `#inlcude <array>`，并非必须引入【它被定义在 `<iterator>` 头文件中，引入`#include <iostream>`就已使用`std::size()`】，不过如果有更多需求，须引入；
        -   `sizeof()`，获取内存所占比特数；
            -   `sizeof(Array)/sizeof(Array[0])`，数组中元素所占比特数；
        -   `strlen()`，仅获取 `C-string` 字符串的有效个数，不包括结尾的 null 字符；

    -   **此外：**

        -   C++ 没有提供基本字符串类型，但作为标准库的一部分，提供了字符串的标准实现；

-   **运算符：**

    -   `=`，赋值；
    -   `++`，自加加；
    -   `--`，自减减；
    -   `+`，加；
        -   `+=`
    -   `-`，减；
        -   `-=`
    -   `*`，乘；
        -   `* =`
    -   `/`，除；
        -   `/ =`
    -   `%`，取余；
        -   `% =`
    -   `&`，按位与；
        -   `& =`
    -   `|`，按位或；
        -   `| =`
    -   `<<`，左移；
        -   `<< =`
    -   `>>`，右移；
        -   `>> =`
    -   `^`，按位异或；
        -   `^ =`
    -   `condition ? expression_if_true : expression_if_false;`，三元运算符；

-   **自定义类型：**

    -   **枚举类型：**

        -   ```c++
            enum PieceType
            {
            	PieceTypeKing = 1,	// 设定为 1
            	PieceTypeQueen,		// 为前驱 +1，为 2
            	PieceTypeRook = 10,	// 设定为 10
            	PieceTypePawn		// 为前驱 +1，为 11
            };
            // 即，某位置的值若未被设定，则，其值为前驱值 +1
            
            PieceType myPiece;
            myPiece = PieceTypeQueen;
            cout << myPiece;
            // 正常输出一个整型值
            
            myPiece = 0;
            // 出现类型不匹配报错
            
            cout << myPiece;
            ```

        -   由于实质上，`enum`类型是一个整型值，但是由于它本身并不是`int`类型，所以能降低风险；不过，虽然无法参与整型运算，但是，本质上，又被解释为整形变量，所以，可以参与到整型变量比较，这同样是一种不安全，使用下面的**强类型枚举**可以解决这个问题；

    -   **强类型枚举：**

        -   **建议用类型安全的 `enum class` 枚举来代替类型不安全的 `enum` 枚举；**

        -   ```c++
            enum class PieceType
            {
            	King = 1,
            	Queen,
            	Rook = 10,
            	Pawn
            };
            
            PieceType piece = PieceType::King;
            
            // 此代码是不合法的
            if (PieceType == 2) {...}
            ```

        -   枚举值名不会超出封闭的作用域，这代表必须要使用**作用域解析操作符**，**这避免了枚举值自动类型转换为整数**；

        -   此外，还可以指定**底层类型**【底层类型可以是 C++ 支持的任何整数类型，如 `int`、`unsigned int`、`long`、`unsigned long` 等。】，例：

            -   ```c++
                enum class PieceType : unsigned long
                {
                	King = 1,
                	Queen,
                	Rook = 10,
                	Pawn
                };
                // 在这里，`PieceType` 的底层类型是 `unsigned long`，这意味着枚举常量的存储将使用无符号长整型。
                ```

    -   **结构体：**

        -   在`.h`文件实现结构体的声明：

            -   ```c++
                // employeestruct.h
                // 在头文件中声明结构体 Employee
                pragma once
                    
                struct Employee
                {
                	char firstInitial;
                	char lastInitial;
                	int employeeNumber;
                	int salary;
                };
                ```

        -   在`.cpp`文件中实现结构体的实现和调用：

            -   ```c++
                // employee.cpp
                // 在头文件中实现结构体 Employee
                #include <iostream>
                #include "employeestruct.h"
                using namespace std;
                
                int main()
                {
                	Employee anEmployee;
                	anEmployee.firstInitial = 'M';
                	anEmployee.lastInitial = 'G';
                	anEmployee.employeeNumber = 42;
                	anEmployee.salary = 80000;
                
                	cout << "Employee: " << anEmployee.firstInitial << anEmployee.lastInitial << emdl;
                	cout << "Number: " << anEmployee.employeeNumber << endl;
                	cout << "Salary: $" << anEmployee.salary << endl;
                
                	return 0;
                }
                ```

-   **条件语句：**

    -   `if/else`

        -   `0/false`，被视为：`false`；
        -   `!0/ture`，被视为：`true`；

    -   `if 初始化器`

        -   `if (<initializer>; <conditional_expression>) { <body> }`

        -   ```c++
            #include <iostream>
            #include <string>
            
            int main() 
            {
                std::string input = "Hello, World!";
            
                // 使用 if 语句初始化器
                if (std::size_t position = input.find("World")
                    ; position != std::string::npos) 
                {
                    std::cout << "'World' found at position: " << position << std::endl;
                } 
                else 
                {
                    std::cout << "'World' not found." << std::endl;
                }
            
                return 0;
            }
            ```

    -   `switch`

        -   ```c++
            switch(short/int/long/long long/enum/enum class)
            {
                case caseValue: 
                    // 如果是强类型枚举，必须使用 case enumclassName::elementName
                    // ... 
                    break;    
            }
            ```

        -    `[[fallthougn]]`，用于有意为之的贯穿；

    -   `switch 初始化器`

        -   `switch (<initializer>, <expression>) { <body> }`

    -   `三元运算符`

-   **逻辑比较运算符：**

    -   `<`
    -   `>`
    -   `<=`
    -   `>=`
    -   `==`
    -   `! =`
    -   `!`
    -   `&`，不采取断路逻辑
    -   `|`，不采取断路逻辑
    -   `&&`，采取断路逻辑
    -   `||`，采取断路逻辑

-   **函数：**

    -   **函数声明**，也称为**“函数原型”**或**“函数头”**，以强调函数的访问、返回方式，而非具体代码，一般位于`.h`文件中；

    -   **函数签名**，指将函数名和参数列表与形参列表组合在一起，但不包括返回值；

    -   **函数定义**，一般位于上述`.h`文件所对应的`.cpp`文件中；

    -   **函数返回类型推断：**

        -   `auto`

            -   ```c++
                auto addnumber(int number1, int number2)
                {
                	return number1 + number2;
                }
                
                // 编辑器自动推出函数的返回值类型
                ```

    -   **当前函数的名称：**

        -   `__func_`，为 `const char[]` 类型；

            -   ```c++
                int addNumbers(int number1, int number2)
                {
                	std::cout << "Function name : " << __func__ << std::endl;
                	// __func__ 为 const char[] 类型
                	return number1 + number2;
                }
                ```

            -   `__func__` ，是编译器提供的宏。

            -   在编译时展开，而不是在运行时展开，这使得它在程序执行期间不会产生额外的运行开销，主要用于调试和日志记录，以便在运行时了解代码的执行流程，而不会影响实际的程序性能；

-   **C 风格数组：**

    -   `typename variableName[constantInteger]`

        -   **初始化方式：**

            -   ```c++
                int myArray[3];
                myArray[0] = 0;
                myArray[1] = 0;
                myArray[2] = 0;
                ```

            -   ```c++
                int myArray[3] = {0};
                int myArray[3] = {};
                // 都起到将所有列表中元素置零的作用
                ```

            -   ```c++
                int myArray[] = {1, 2, 3, 4};
                // 自动推导出列表长度，并初始化每个位置的值
                ```

            -   ```c++
                int myArray[3] = {2};
                // 将数组第一个元素置为 2，其余置为 0
                ```

            -   ```c++
                int myArray[3] = {1, 2};
                // 将数组第一个元素置为 1，将数组第二个元素置为 2，其余置为 0
                ```

    -   `typename variableName[constantInteger][constantInteger]`

-   `std::array`

    -   `#include <array>`，此头文件必须引入；

        -   **优点：**

            -   它总是可以获取自身大小；
            -   它不会自动转化为指针，从而避免 C 风格数组引发的类型错误；
            -   它具有迭代器，可以方便地遍历元素；

        -   ```c++
            std::array<type, constantInteger> variableName = {...}
            std::cout << "Array size : " << variableName.size() << std::endl;
            
            std::array<int, 3> arr = {9, 8, 7}; 
            std::cout << "Array size = " << arr.size() << std::endl;
            ```

        -   **C 风格和 `std::array` 的数组都具有固定的大小，在编译过程中不会改变；**

        -   如果希望数组的大小是动态变化的，则可以使用`std::vector`；

-   `std::vector`

    -   `#include <vector>`，此头文件必须引入；

        -   用户不必担心内存的管理，因为 vector 将自动动态地分配足够的内存来存放元素。

        -   ```c++
            // Create a vector of integers
            std::vector<int> myVector = {11, 12};
            
            // Add some more integers to the vector using push_back()
            myVector.push_back(33);
            myVector.push_back(44);
            
            // Delete some more integer to the vector using pop_back()
            myVector.pop_back();
            
            // 删除中间元素，后面元素顺位向前移动，使用 erase()
            myVector.erase(myVector.begin());	// 删除索引为 0 元素
            myVector.erase(myVector.begin() + 2); // 删除索引为 2 元素
            
            // Access elements
            std::cout << "1st element: " << myVector[0] << endl;
            ```

-   **结构化绑定：**

    -   **优点：**

        -   无需显式地访问元素索引或成员变量，可以方便地使用`std::pair`、`std::tuple`、结构体【要求：所有非静态成员都是公有的】；
        -   提高代码可读性，直观、简单；
        -   减少手动索引和访问机制可能引起的错误；

    -   `std::pair`

        -   `#include <utility>`，此头文件必须引入；

        -   `std::pair<typeName, typeName>`

            -   ```c++
                std::pair<typeName, typeName> function()
                {
                    // ...
                    
                    return {value, value};
                    // 此处使用结构化绑定
                }
                ```

            -   ```c++
                std::pair<typeName, typeName> variableName = funcion();
                
                // 使用 auto 简化获取过程
                auto [firstValue, secondValue] = function();
                
                /*----------------------------示例-------------------------------*/
                #include <iostream>
                #include <utility>  // 支持 std::pair
                
                // 函数返回 std::pair
                std::pair<int, std::string> getPair()
                {
                    int a = 10;
                    std::string b = "example";
                    return {a, b};
                }
                
                int main()
                {
                    // 接收 std::pair 的返回值
                    std::pair<int, std::string> myPair = getPair();
                
                    // 使用 first 和 second 访问元素
                    std::cout << "First value: " << myPair.first << std::endl;
                    std::cout << "Second value: " << myPair.second << std::endl;
                
                    // 使用结构化绑定直接接收两个值
                    auto [a, b] = getPair();
                    std::cout << "a: " << a << ", b: " << b << std::endl;
                
                    return 0;
                }
                
                ```

        -   `std::pair<typeName, typeName> Pair = {value, value};`，使用列表初始化，严格类型匹配，不支持隐式转换；

        -   `std::pair<typeName, typeName> Pair = std::make_pair(value, value);;`，使用`std::make_pair()`，可自动推导类型，支持隐式转换；

        -   `variableName.first`，用于返回第一个结构参数；

        -   `variableName.second`，用于返回第二个结构参数；

    -   `std::tuple`

        -   **`#include <tuple>`**，此头文件必须引入；

        -   **`std::tuple<typeName1, typeName2, ...>`**
          
            -   ```cpp
                std::tuple<typeName1, typeName2, ...> function()
                {
                    // ...
                    
                    return {value1, value2, ...};
                    // 此处使用结构化绑定
                }
                ```
            
            -   ```c++
                std::tuple<typeName1, typeName2, ...> variableName = function();
                
              // 使用 auto 简化获取过程
              auto [firstValue, secondValue, ...] = function();
              
              // std::get<N>(variableName) 用于访问第 N 个元素，N 从 0 开始计数
              // 获取第一个元素
              auto firstValue = std::get<0>(variableName); 
              
              // 获取第二个元素
              auto secondValue = std::get<1>(variableName); 
              
              /*----------------------------示例-------------------------------*/
              #include <iostream>
              #include <tuple>
              
              // 函数返回 std::tuple
              std::tuple<int, double, std::string> getValues()
              {
                  int a = 10;
                  double b = 20.5;
                  std::string c = "example";
                  return {a, b, c};
              }
              
              int main()
              {
                  // 接收 std::tuple 的返回值
                  std::tuple<int, double, std::string> values = getValues();
              
                  // 使用 std::get<N> 获取元素
                  std::cout << "First value: " << std::get<0>(values) << std::endl;
                  std::cout << "Second value: " << std::get<1>(values) << std::endl;
                  std::cout << "Third value: " << std::get<2>(values) << std::endl;
              
                  // 使用结构化绑定直接接收多个值
                  auto [a, b, c] = getValues();
                  std::cout << "a: " << a << ", b: " << b << ", c: " << c << std::endl;
              
                  return 0;
              }
              ```
          
        -   `std::tuple<typeName, typeName> Tuple = {value, value};`，使用列表初始化，严格类型匹配，不支持隐式转换；

        -   `std::tuple<typeName, typeName> Tuple = std::make_tuple(value, value);;`，使用`std::make_tuple()`，可自动推导类型，支持隐式转换；

        -   `std::get<0>(variableName)`，用于返回第一个结构参数；

        -   `std::get<1>(variableName)`，用于返回第二个结构参数；

        -   `std::get<2>(variableName)`，用于返回第三个结构参数；

    -   `auto、结构体、std::pair、std::tuple`

        -   ```c++
            struct Point
            {
            	double mX;
            	double mY;
            	double mZ;
            };
            
            Point point;
            point.mX = 1.0;
            point.mY = 2.0;
            point.mZ = 3.0;
            
            auto [x, y, z] = point;
            ```

-   **循环：**

    -   `while () {...}`

    -   `do {...} while ()`

    -   `for (init_state; loop_condition; iter_expr) {...}`

    -   `基于区间的 for 循环`

        -   类似于 Python，允许方便地迭代容器中的元素：可用于 C 风格的数组、初始化列表等，也可用于具有返回迭代器的 `begin()` 和 `end()` 函数的类型，例如，`std::array`、`std::vector`等其他所有标准库容器：

            -   ```c++
                int numbers[] = {100, 200, 300};
                
                // 使用范围 for 循环遍历 C 风格数组
                for (int num : numbers) 
                {
                    std::cout << num << " ";
                }
                std::cout << std::endl;
                
                /*---------------------------------------------------------------*/
                // 使用范围 for 循环遍历初始化列表
                for (auto value : {1, 2, 3, 4, 5}) 
                {
                    std::cout << value << " ";
                }
                std::cout << std::endl;
                
                /*---------------------------------------------------------------*/
                std::array<int, 3> numbers = {10, 20, 30};
                
                // 使用范围 for 循环遍历 std::array
                for (auto num : numbers) 
                {
                    std::cout << num << " ";
                }
                std::cout << std::endl;
                
                /*---------------------------------------------------------------*/
                std::vector<int> numbers = {1, 2, 3, 4, 5};
                    
                // 使用范围 for 循环遍历 std::vector
                for (int num : numbers) 
                {
                    std::cout << num << " ";
                }
                std::cout << std::endl;
                ```

-   **初始化列表：**

    -   `{...}`，被称为**初始化列表**；

    -   **注意：结构化绑定和初始化列表有很多时候，几乎一起出现的，因此可能混淆，我用下面两个例子说明一下情况：**

        -   **初始化列表并结构化绑定解构：**

            -   ```c++
                #include <iostream>
                #include <tuple>
                
                int main()
                {
                    // 使用初始化列表初始化一个 std::tuple
                    auto myTuple = std::make_tuple(1, 2.5, 'a');
                
                    // 使用结构化绑定解构 tuple
                    auto [intValue, doubleValue, charValue] = myTuple;
                
                    std::cout << "intValue: " << intValue << ", doubleValue: " << doubleValue << ", charValue: " << charValue << std::endl;
                
                    return 0;
                }
                ```

        -   **结构化绑定解构初始化列表：**

            -   ```c++
                #include <iostream>
                #include <utility>
                
                std::pair<int, double> createPair() 
                {
                    return {42, 3.14}; 
                    // 使用初始化列表返回 std::pair
                }
                
                int main() 
                {
                    // 使用结构化绑定解构 std::pair
                    auto [integerPart, decimalPart] = createPair(); 
                
                    std::cout << "Integer part: " << integerPart << ", Decimal part: " << decimalPart << std::endl;
                
                    return 0;
                }
                
                ```

    -   值得关注的是：初始化列表的左值可以是不确定数量的容器；然而，结构化绑定的左值必须为确定数量的容器；

-   **`initializer_list`**

    -   `#include <initializer_list>`，此头文件必须引入；

    -   这个也被称为**初始化列表**，不过它是一个模板类，以十分方便地用于编写 **可变数量参数** 的函数；

    -   往往会出现 **结构化绑定、`{...}`、`initializer_list`**，三者同时出现，互为彼此的情况：

        -   ```c++
            #include <iostream>
            #include <vector>
            #include <initializer_list>
            
            // 函数：将 initializer_list 转换为 vector
            template <typename T>
            std::vector<T> createVector(std::initializer_list<T> list) 
            {
                // 将 initializer_list 转换为 vector
                return std::vector<T>(list); 
            }
            
            int main() 
            {
                // 使用 initializer_list 初始化 vector
                // 创建一个包含多个元素的 vector
                auto myVector = createVector({1, 2, 3, 4, 5}); 
            
                // 输出 vector 中的元素
                for (const auto& value : myVector) 
                {
                    std::cout << value << " "; // 打印元素
                }
                std::cout << std::endl; // 换行
            
                return 0;
            }
            
            /*---------------------------------------------------------------*/
            #include <initializer_list>
            using namespace std;
            
            // 定义可变数量参数累加函数
            int makeSun(initializer_list<int> lst)
            {
            	int total = 0;
            	for (int value : lst)
            	{
            		total += value;
            	}
            
            	return total;
            }
            
            int a = makeSun({ 1, 2, 3 });
            int b = makeSun({ 10, 20, 30, 40, 50, 60 });
            
            // 初始化列表是类型安全的，会定义列表中允许的类型。对于此处的 makeSun() 函数，初始化列表所有元素必须都是整数。
            // 尝试使用 double 数值进行调用，将会导致编译器生成错误或警告
            int c = makeSun({ 1, 2, 3.0 });
            ```

-   **字符串：**

    -   `const char *` 和 `char []`
    -   `std::string`
        -   `#include <string>`，此头文件必须引入；

-   **指针：**

    -   **堆栈（Stack）** 是一种后进先出（LIFO）的数据结构，通常用于管理函数调用和局部变量；

    -   而 **堆（Heap）** 是一种动态内存分配区，允许程序在运行时申请和释放内存，通常用于存储对象和数据结构。

    -   指针都应当进行**初始化**为：`nullptr`；

        -   `int* myIntegerPointer = nullptr;`

    -   **初始化后**，再考虑使用 **new** 分配内存：

        -   `myIntegerPointer = new int;`

    -   **分配内存后**，再考虑使用 ***** 解引用运算符，进行赋值：

        -    `* myIntegerPointer = 8;`
            -   注意，在解引用前，指针必须是有效的，否则，对 NULL 或 未初始化的指针解除引用会导致不可确定的行为；

    -   **分配释放后**，再考虑使用 **&** 取地址运算符，重新赋值：

        -   `delete delete myIntegerPointer;`
        -   `myIntegerPointer = nullptr;`
            -   每次置空时，都要重新初始化为：`nullptr`；
        -   `int i = 9;`
        -   `int* myIntegerPointer = &i;`

    -   **使用结束后**，需要使用 **delete** 释放内存，并置空指针：

        -   `delete myIntegerPointer;`
        -   `myIntegerPointer = nullptr;`

    -   对于**结构体**，C++可以使用以下方式来处理指针：

        -   先用 ***** 进行解引用，再用 **.** 语法来访问结构体的内部：

            -   ```c++
                Employee* anEmployee = getEmployee();
                // getEmployee() 是对 Employee 结构(类)的封装
                std::cout << (*anEmployee).salary << endl;
                ```

        -   直接使用 **->** 来对指针进行解引用和访问操作：

            -   ```c++
                Employee* amEmployee = getEmployee();
                std::cout << anEmployee->salary << std::endl;
                ```

        -   可以使用以下方法进行解引用和访问操作的检查：

            -   ```c++
                bool isValidSalary = (anEmployee && anEmployee->salary > 0);
                // 注意，这里会短路，因此，如果是空指针，就会不再解引用后面的指针
                ```

-   **动态分配数组：**

    -   指针都应当进行**初始化**为：`nullptr`；
        -   `int* myIntegerPointer = nullptr;`
    -   **初始化后**，再考虑使用 **new typeName[]** 分配内存：
        -   `int* myVariableSizeArray = new int[arraySize];`
    -   **使用结束后**，需要使用 **delete[]** 释放内存，并置空指针：
        -   `delete[] myIntegerPointer;`
        -   `myIntegerPointer = nullptr;`
    -   避免使用 C 中的 `malloc()` 和 `free()`

-   **`NULL` 对比 `nullptr`：**

    -   在 C++11 之前，常量 NULL 用于表示空指针。将 NULL 定义为常量 0，会导致一些问题：

        -   ```c++
            void func(char* str)
            {
            	std::cout << "char* version" << std::endl;
            }
            void func(int i)
            {
            	std::cout << "int version" << std::endl;
            }
            
            int main()
            {
            	func(NULL);
            	// 由于使用的 NULL 指针等价于整数 0，所以调用的是 func 的整数版本，而非指针版本
            	return 0;
            }
            ```

    -   C++11 及之后，都应当使用 `nullptr` 作为真正的空指针，来解决这个问题；

-   **智能指针：**

    -   **`#include <memory>`，但一般引入`#include <iostream>`就足够；**

    -   为了避免常见了内存错误，从 C++11 开始逐步淘汰 C 风格的 **裸** 指针，并引入了**智能指针**的概念。

    -   **智能指针**在超出作用域时，就会自动释放内存，因此，不必再每次手动释放资源；

    -   `std::unique_ptr`

        -   **优点：**
            -   内存和资源始终被释放，即使执行返回语句或抛出异常；
            -   超出作用域或者被删除时，会自动释放内存或资源；
            -   拥有数据的“独占所有权”，不能将其拷贝非其他指针，保持对资源的独占，只能通过“转移所有权”【`std::move`】来传递，同时，避免了潜在的重复释放内存；
            -   
        -   `std::make_unique<type>()`，定义于 C++14；
            -   `auto anEmployee = std::make_enique<Employee>();`
        -   `std::make_unique<type[]>(listSize)`
            -   `auto employees = std::make_enique<Employee>(10);`
        -   如果用户编译器与 C++ 14 不兼容【一般不会】，可使用如下形式定义：
        -   `std::unique_ptr<type> myElement (new type);`
            -   `std::unique_ptr<Employee> anEmployee (new Employee);`
        -   `std::unique_ptr<type[]> elementName (new type[listSize]);`
            -   `std::unique_ptr<Employee[]> employees (new Employee[10]);`
        -   注意，对于`amEmployee`有`amEmployee->salary`；
        -   注意，对于` employees`有` employees[0].salary`；
        -   两者之所以有区别是因为：
            -   `anEmployee`是指向`Employee`对象的`unique_ptr`；
            -   `employee[0]`中的 **[]** 具有解引用的作用，相当于取出了第一个对象，而非第一个指针，所以使用 **.** 直接访问；

    -   `std::shared_ptr`

        -   使用引用计数来决定是否释放指针，当引用计数为 0，就表示数据不再拥有任何拥有者，于是释放指针引用的对象；
        -   允许数据的分布式“所有权”；
        -   `std::make_shared<type>()`
            -   `auto anEmployee = std::make_unique<Employee>();`
        -   C++17 **不允许**使用`std::make_shared<[]>()`的方式，来创建共享数组；
            -   `std::make_shared` 会同时分配两块内存：
                -   一块内存用于存储对象本身（`T` 类型），即 `new T()`。
                -   另一块内存用于存储引用计数等控制块（`std::shared_ptr` 需要这些信息来管理对象的共享）。
            -   这种内存布局的目的是提高性能，减少内存碎片和分配的次数。具体来说，它会为对象和引用计数器分配一个连续的内存块，这样可以提高缓存友好性。这种设计对于单一对象的内存管理非常高效，但对于数组来说不适用；
            -   `std::make_shared<>()` 设计假设你管理的是单一对象，它不会知道你需要一个数组，因此它会调用 `delete` 来释放内存，数组的内存管理要求在释放内存时使用 `delete[]`（而不是 `delete`），导致错误的内存释放；且用 `std::make_shared` 创建一个数组时，类型推导和构造函数会面临问题。`std::make_shared` 并不支持数组类型的特殊管理；
        -   `std::shared_ptr<type> elementName (new type);`
            -   `std::shared_ptr<Employee> anEmployee (new Employee);`
        -   `std::shared_ptr<type[]> elementName (new type[listSize]);`，C++17 开始允许这样做；
            -   `std::shared_ptr<Employee[]> employees (new Employee[10]);`

    -   | 特性         | `std::unique_ptr`                        | `std::shared_ptr`                  |
        | ------------ | ---------------------------------------- | ---------------------------------- |
        | **所有权**   | 独占所有权，只能有一个所有者             | 共享所有权，可以有多个所有者       |
        | **内存管理** | 自动销毁内存，不能共享                   | 自动销毁内存，引用计数管理         |
        | **复制**     | 不支持复制，只能转移所有权 (`std::move`) | 支持复制，增加引用计数             |
        | **使用场景** | 资源只有一个所有者，避免资源泄漏         | 资源需要多个所有者，避免悬挂指针   |
        | **适用场景** | 管理独占资源，如动态分配的内存           | 管理共享资源，如数据库连接、线程池 |

    -   **默认使用 `std::unique_ptr` 是更优选**，因为它简单且效率高，减少了资源管理中的复杂性；

    -    **`std::shared_ptr`** 应该在需要多个对象共享资源所有权时使用。

    -   对于，第二种声明方法也就是：`std::unique_ptr<type> myElement (new type);` 和 `std::shared_ptr<type> elementName (new type);`，会存在这样的问题 —— **在初始化过程中抛出异常**，智能指针对象本身就不会被正常构造完成，导致原本应该管理动态内存的智能指针**无法执行析构操作**，进而造成**内存泄漏**。

        -   **因此，尽可能地使用`std::make_unique` 或`std::make_shared`；**
            -   它们在内部会直接创建智能指针并返回，而不需要手动调用 `new`。即使在对象的构造过程中抛出异常，**内存分配和指针管理都是在一个操作中完成的，不会导致资源泄漏**。

    -   此外，**如果知道 `auto_ptr`，应当忘记它，因为 C++ 11/14 不赞成使用它，而 C++17 已经废弃它；**

-   **`const`**

    -   C++ 废弃了 C 中的宏定义 `#define` 机制，转而使用 `const`关键字来定义常量；
    -   一般情况下，我们都会让定义的常量全部都使用大写字母【不过，这最终还是要看团队的代码规范】：
        -   `const double PI = 3.14159;`
    -   `const`的另一个用法就是保护函数参数：
        -   `returnType function(const enterType variable)`
        -   这将防止代码修改此变量【如若修改，编译不通过】；

-   **`&`**

    -   `returnType function(enterType& variable)`
        -   引用传递参数【本质上是传递指针】，因此，一但修改，则原参数也被修改【也称 **按引用传递**】；
    -   配合 `const`，实现“无额外复制损耗、防止代码修改”的引用传递参数了【也称为 **按 const 引用传递**】；

-   **异常：**

    -   C++ 十分灵活，但并不是非常安全。异常就是试图增加安全性的语言特性；

-   **`std::invalid_argument`**

    -   `#include <stdexcept>`，此头文件必须引入；

    -   除以零的异常抛出：

        -   ```c++
            double divideNumbers(double numerator, double denominator)
            {
            	if (denominator == 0)
            	{
                    // 当执行 throw 行时，程序会立即结束而且不会返回值
            		throw std::invalid_argument("Denominator cannot be 0.");
            	}
            	return numerator / denominator;
            }
            ```

    -   将函数调用放到 `try/catch` 块中就可以辅助捕获异常并进行处理：

        -   ```c++
            try
            {
                // 成功执行，结果会输出给用户
            	std::cout << divideNumbers(2.5, 0.5) << std::endl;
                
                // 抛出一个异常，不会返回值，唯一的输出是捕获异常时输出的错误信息
            	std::cout << divideNumbers(2.3, 0) << std::endl;
                
                // 根本不会执行，因为第二次调用抛出了一个异常，导致程序跳转到 catch 块
            	std::cout << divideNumbers(4.5, 2.5) << std::endl;
            }
            catch (const std::invalid_argument& exception)
            {
            	std::cout << "Expression caught: " << exception.what() << std::endl;
            }
            ```

-   **`auto`**

    -   `auto`会自动去除 引用 和 `const` 限定符，从而创建副本！

    -   如果不需要副本，可使用 `auto&` 或 `const auto&`；

        -   ```c++
            #include <string>
            
            const std::string message = "Test";
            
            const std::string& foo(const std::string& message)
            {
            	return message;
            }
            
            // fl 被推导为 const std::string（副本）
            auto fl = foo();
            
            // f1 被推导为 const std::string&（引用）
            auto& f1 = foo();
            
            // f2 被推导为 const std::string&（引用）
            const auto& f2 = foo();
            ```

-   **`decltype`**

    -   关键词 `decltype` 把表达式作为实参，计算出该表达式的类型；

        -   ```c++
            int x = 123;
            decltype(x) y = 456;
            ```

    -   **`auto` 与 `decltype` 的区别在于，`decltype` 未除引用和 `const` 限定符。**

    -   再来分析返回 `const string` 引用的 `foo()` 函数。按照如下方式使用 decltype 定义 `f2`，导致 `f2` 的类型为 `const string&`，从而不生成副本：

        -   ```c++
            decltype(foo()) f2 = foo();
            ```

    -   **在这里并不能体现 `decltype` 的价值，但是，在模板环境中， `decltype` 会变得十分强大；**

-   **`OPP`**

    -   C++ 在很多方面，较 C 来说，是“更好的 C”；
    -   但是，它们的本质区别在于**“面向对象”**；

-   **类的访问级别：**

    -   在 C++ 中，类的访问级别控制了类成员（属性和方法）对外部代码的可访问性。类的访问级别有 **三种主要的访问修饰符**：`public`、`protected` 和 `private`。此外，C++ 还允许使用 `friend` 来控制友元关系。

    -   | 访问修饰符      | 成员可访问性                                           | 适用范围                   | 说明                                                         |
        | --------------- | ------------------------------------------------------ | -------------------------- | ------------------------------------------------------------ |
        | **`public`**    | 类外部可以访问类中的成员。                             | 类外部，类内部             | 成员是公开的，可以被类外部代码直接访问（包括继承类）。       |
        | **`protected`** | 类外部不能直接访问；但可以被派生类访问。               | 类内部，派生类内部         | 该成员只能在类内部以及派生类内部访问。不能被类外部直接访问。 |
        | **`private`**   | 只能在类的成员函数中访问；不能被外部访问或派生类访问。 | 类内部                     | 成员是私有的，只能在该类的成员函数中访问。外部代码和派生类不可访问。 |
        | **`friend`**    | 类的成员或函数可以访问友元类或函数的私有和保护成员。   | 类外部（友元类、友元函数） | 用于定义允许访问私有或保护成员的函数或类，即“友元”。友元不受访问级别限制。 |

-   **类的声明：**

    -   ```c++
        // AirlineTicket.h
        #pragma once
        #include <string>
        
        class AirlineTicket
        {
        public:
        	// 构造类
        	AirlineTicket();
        
        	// 析构类
        	~AirlineTicket();
        
        	double calculatePriceInDollars() const;
        
        	const std::string& getPassengerName() const;
        	void setPassageName(const std::string& name);
        
        	int getNumberOfMiles() const;
        	void setNumberOfMiles(const int miles);
        
        	bool hasEliteSuperRewardsStatus() const;
        	void setHasEliteSuperRewardsStatus(const bool status);
        private:
        	std::string mPassengerName;
        	int mNumberOfMiles;
        	bool mHasEliteSuperRewardsStatus;
        };
        
        // 约定：在类的每个数据成员之前加上小写字母 m, 如 mPassengefName
        ```

    -   始终遵守**`const 正确性原则`** ，尽可能使不修改对象状态的成员函数、方法和指针声明为 `const`，以确保对象的不可变性，并防止无意中修改对象的状态。

-   **构造函数的初始化：**

    -   **构造函数初始化器（constructor initializer list）【推荐使用】：**

        -   如果没有构造函数初始化器，就会在构造函数体内对成员变量进行默认构造，然后在被赋予实际的值（比如通过赋值语句）【如：`string`会被首先初始化为 `''`，再在赋值语句中，进行赋值，造成额外的性能开销；对于内置类型`int`、`double`，它们的默认构造就是：**不进行任何构造**，从而保持未定义的值】；

        -   **优点【这部分内容可能有些难以理解，不过十分重要，建议多读几遍，并询问 chatGPT，来帮助理解，否则，很容易理解错这里面的“微妙”关系】：**

            -   构造函数初始化器使得构造函数更加简单易读；

            -   在对象构造时，成员变量直接初始化为指定的值，而不是先默认初始化再在构造函数体内赋值【在构造函数体内赋值，成员变量先会被默认初始化（例如对于基本数据类型，初始化为 0 或垃圾值），然后再被赋予指定的值，这会造成不必要的性能损失，特别是在成员变量较多或数据类型较复杂时】；

            -   适用于 `const` 成员和引用类型成员，`const` 成员必须在初始化列表中进行初始化，因为 `const` 变量一旦被初始化之后，它们的值就不能再改变。如果你尝试在构造函数体内赋值给 `const` 成员变量，编译器会报错。但是，可以通过构造函数初始化器来实现初始化绑定【对于引用类型变量，也是如此】：

                -   ```c++
                    class MyClass 
                    {
                    private:
                        const int x;   // const 成员变量
                        int& ref;      // 引用类型成员
                    
                    public:
                        MyClass(int a, int& b) 
                        {
                            x = a;      // 错误：不能在构造函数体内为 const 成员赋值
                            ref = b;    // 错误：不能在构造函数体内为引用成员赋值
                        }
                    };
                    ```

                -   ```c++
                    class MyClass 
                    {
                    private:
                        const int x;   // const 成员变量
                        int& ref;      // 引用类型成员
                    
                    public:
                        MyClass(int a, int& b) : x(a), ref(b) 
                        {  // 在初始化列表中初始化
                        }
                    };
                    ```

                -   ```c++
                    class MyClass 
                    {
                    private:
                        const int a;
                        int& b;
                    
                    public:
                        // 构造函数初始化列表初始化成员
                        MyClass(int x, int& y) : a(x), b(y) 
                        {
                            // a = x;    // 错误：不能在构造函数体内赋值给 const 成员
                            // b = y;    // 错误：引用成员不能在构造函数体内赋值
                        }
                    };
                    ```

            -   **初始化列表的顺序**：初始化列表中的顺序决定了计算每个成员变量的值的顺序；**实际的初始化顺序**：成员变量的实际初始化顺序是根据它们在类中 **声明的顺序** 来确定的，而不是根据**初始化列表的顺序**。

                -   ```c++
                    class MyClass 
                    {
                    public:
                        int x;
                        int y;
                    
                        MyClass(int val) 
                        {
                            x = y + val;  // 使用 y 来初始化 x
                            /* 这行代码在构造函数体内执行时，y 还没有被初始化，所以这里的 y 会是一个未定义值。x 将会被初始化为 y + val，但由于 y 没有初始化，它的值是不可预测的，这可能导致 x 的计算结果不符合预期。*/
                            
                            y = 2 * val;  // 在构造函数体内给 y 赋值
                            /* 只有在执行了 y = 2 * val; 之后，y 的值才被初始化为 2 * val，而此时 x 的值已经被计算出来了，依赖于未初始化的 y，因此出现了问题。*/
                        }
                    };
                    ```

                -   ```c++
                    class MyClass 
                    {
                    public:
                        int x;  // 先声明 x
                        int y;  // 再声明 y
                    
                        // 先算 x(y + val)，导致未定义行为，再计算 y(2 * val)
                        // 先赋值 x，再赋值 y
                        MyClass(int val) : x(y + val), y(2 * val) 
                        { 
                        }
                    };
                    ```

                -   ```c++
                    class MyClass 
                    {
                    public:
                        int x;
                        int y;
                    
                        // 先算 y(2 * val)，再计算 x(y + val)
                        // 先赋值 x，再赋值 y
                        MyClass(int val) : y(2 * val), x(y + val) 
                        { 
                        }
                    };
                    ```

            -   如果类有基类，那么想要构造基类，就要为**基类的成员就必须指定相应的构造函数**【由于基类必须先于派生类构造完成，因此不可能说在派生类的构造函数中再去对基类的构造函数进行调用，因为先后顺序的限制使得永远无法跨过这条障碍】，因此就必须通过 **初始化列表进行初始化** 或者通过 **默认构造函数初始化**）。也就是说：**父类的构造函数调用必须在初始化列表中显式指定，而不能通过构造函数体内赋值来完成**；

            -   此外，**C++ 规定，在对象的生命周期中，成员一旦被初始化就不能再被赋值。这是为了确保对象的初始化过程是安全且一致的。**显然，在派生类调用基类的默认构造函数或者实现了基类初始化列表初始化后，**基类的成员就已经处于有效的初始化状态，如果允许在构造函数体内修改已初始化的成员，可能会导致对象状态的不一致或不明确的行为。否则，会违反对象状态一致性的要求，可能会引发潜在的逻辑错误**。也就是说：**一但基类中的成员被初始化完毕，就不能再为其中任何成员赋值**；

            -   总而言之，言而总之：**初始化列表应当是为成员变量提供初始化值的唯一地方，虽然，虽然看起来这条规则对于初学者来说似乎不那么重要，但它实际上能帮助避免很多潜在的错误和设计上的问题。**

                -   ```c++
                    class Base 
                    {
                    public:
                        int a;
                        Base(int x) : a(x) {}  // 基类构造函数初始化 a
                    };
                    
                    class Derived : public Base 
                    {
                    public:
                        int b;
                        Derived(int x, int y) : Base(x), b(y) {}  // 通过初始化列表初始化基类成员 a 和派生类成员 b
                    };
                    ```

        -   ```c++
            // AirlineTicket.h
            AirlineTicket::AirlineTicket()
            	: mPassengerName("Unknown Passenger")
            	, mNumberOfMiles(0)
            	, mHasEliteSuperRewardsStatus(false)
            {
            }
            ```

        -   























